#!/usr/bin/env ruby

# frozen_string_literal: true

require 'dotenv'
require 'mqtt'
require 'sequel'
require 'logger'

Dotenv.load('.env.local', '.env')
LOGGER = Logger.new('log/mqtt_messages.log', 10, 1_024_000)
LOG = ENV['ENABLE_LOGGING'] =~ /y/i

MQTT_HOST = ENV['MQTT_HOST']
MQTT_PORT = ENV['MQTT_PORT']
db_name = ENV['DATABASE_URL']
DB = if db_name == 'tinytds'
       LOGGER.info "Connection to MSSQL: #{ENV['MSSQL_HOST']}:#{ENV['MSSQL_PORT']}/#{ENV['MSSQL_DB']}" if LOG
       Sequel.connect(adapter: :tinytds, host: ENV['MSSQL_HOST'], port: ENV['MSSQL_PORT'],
                      database: ENV['MSSQL_DB'], user: ENV['MSSQL_USER'], password: ENV['MSSQL_PW'])
     else
       LOGGER.info "Connection to Postgresql: #{db_name}" if LOG
       Sequel.connect(db_name)
     end
DB.extension(:connection_validator) # Ensure connections are not lost over time.
Sequel.application_timezone = :local
Sequel.database_timezone = :utc

Signal.trap('INT') do
  puts "\nReceived interupt - cleaning up...\n"
  # exit
  @stopper = true
  @threads.each { |t| t.kill if t&.alive? }
end

que = Queue.new
@threads = []
LOGGER.info 'Started...' if LOG

@threads << Thread.new do
  MQTT::Client.connect(MQTT_HOST, MQTT_PORT) do |c|
    # Might have to listen for '#' and append to log files named after topics too...
    # c.get('Gossamer/data/#') do |topic, message|
    c.get('#') do |topic, message|
      if topic.start_with?('Gossamer/data/')
        LOGGER.info "Received `#{topic}` with: `#{message}`" if LOG
        # puts "#{topic}\n"
        # puts "#{message}\n"
        # puts "#{topic}: #{message}. #{c.will_qos}. #{c.client_id}.\n"
        que << { topic: topic, msg: message, qos: c.will_qos }
      elsif LOG
        LOGGER.info "Disacarded non-matching topic: `#{topic}` with: `#{message}`"
      end
    end
  end
end

@threads << Thread.new do
  loop do
    res = que.pop
    message = res[:msg]
    break if @stopper

    parts = message.split('#')
    # ["<GossamerData", "MesModule=\"CLM-01\"", "Module=\"GOS-01\"", "Line=\"1\"", "MachineID=\"5\"",
    # "PackCount=\"0\"", "LabelPrintQty=\"2\"", "PrintCommand=\"0\"", "Accumulator-70%=\"0\"",
    # "Accumulator%=\"11\"", "Alarm-Active=\"57901\"", "Alarm-Code=\"0\"", "TotalCount=\"66729\"",
    # "Producing=\"58698\"", "NoProduct=\"3056\"", "NoCartons=\"570\"", "BuildBack=\"6\"",
    # "Stopped=\"40210\"", "Fault=\"28736\"", "Total-Spare-1=\"0\"", "Total-Spare-2=\"0\"",
    # "Total-Spare-3=\"0\"", "ActiveCounter=\"0\"", "SpeedPerHour=\"0\"", "/>"]
    rec = {
      qos: res[:qos],
      topic: res[:topic], # 'Gossamer/data',
      mesmodule: res[:topic].delete_prefix('Gossamer/data/'),
      payload: message,
      created_at: Time.now
    }

    parts.each do |part|
      key = part.split('=')
                .first
                .gsub('-', '_')
                .gsub('%', '_perc')
                .gsub(/^module/i, 'plc_module')
                .gsub('Line', 'packline')
                .downcase
      rec[key] = part.split('=').last
    end
    DB[:mqtt_msg].insert(rec)
  end
end
@threads.each(&:join)
__END__

-- POSTGRESQL version of table:

CREATE TABLE mqtt_msg (
	id int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  topic character varying(255),
  qos integer,
  payload text,
  mesmodule text,
  plc_module text,
  packline integer,
  machineid integer,
  packcount integer,
  labelprintqty integer,
  printcommand integer,
  accumulator_70_perc integer,
  accumulator_perc integer,
  alarm_active integer,
  alarm_code integer,
  totalcount integer,
  producing integer,
  noproduct integer,
  nocartons integer,
  buildback integer,
  stopped integer,
  fault integer,
  total_spare_1 integer,
  total_spare_2 integer,
  total_spare_3 integer,
  activecounter integer,
  speedperhour integer,
  created_at timestamptz,
	CONSTRAINT mqtt_msg_pkey PRIMARY KEY (id)
);

["MesModule => CLM-01", "Module => GOS-01", "Line => 1", "MachineID => 5", "PackCount => 0", "LabelPrintQty => 2", "PrintCommand => 0", "Accumulator_70_perc => 0", "Accumulator_perc => 11", "Alarm_Active => 57901", "Alarm_Code => 0", "TotalCount => 66729", "Producing => 58698", "NoProduct => 3056", "NoCartons => 570", "BuildBack => 6", "Stopped => 40210", "Fault => 28736", "Total_Spare_1 => 0", "Total_Spare_2 => 0", "Total_Spare_3 => 0", "ActiveCounter => 0", "SpeedPerHour => 0"]


CREATE TABLE dbo.mqtt_msg (
	id int IDENTITY(1,1) NOT NULL,
	topic nvarchar(255) COLLATE Latin1_General_CP1_CI_AS NULL,
	qos int NULL,
	payload nvarchar(255) COLLATE Latin1_General_CP1_CI_AS NULL,
	mesmodule nvarchar(255) COLLATE Latin1_General_CP1_CI_AS NULL,
	plc_module nvarchar(255) COLLATE Latin1_General_CP1_CI_AS NULL,
	packline int NULL,
	machineid int NULL,
	packcount int NULL,
	labelprintqty int NULL,
	printcommand int NULL,
	accumulator_70_perc int NULL,
	accumulator_perc int NULL,
	alarm_active int NULL,
	alarm_code int NULL,
	totalcount int NULL,
	producing int NULL,
	noproduct int NULL,
	nocartons int NULL,
	buildback int NULL,
	stopped int NULL,
	fault int NULL,
	total_spare_1 int NULL,
	total_spare_2 int NULL,
	total_spare_3 int NULL,
	activecounter int NULL,
	speedperhour int NULL,
	created_at datetime NOT NULL,
	CONSTRAINT PK_mqtt_msg PRIMARY KEY (id)
);
